'use strict';

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var sqlite3 = _interopDefault(require('sqlite3'));
var fs = _interopDefault(require('fs'));
var path = _interopDefault(require('path'));

var _createClass$1 = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck$1(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * SQLite client library for Node.js applications
 *
 * Copyright Â© 2016 Kriasoft, LLC. All rights reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.txt file in the root directory of this source tree.
 */

let Statement = function () {
  function Statement(stmt, Promise) {
    _classCallCheck$1(this, Statement);

    this.stmt = stmt;
    this.Promise = Promise;
  }

  _createClass$1(Statement, [{
    key: "bind",
    value: function bind(...params) {
      return new this.Promise((resolve, reject) => {
        this.stmt.bind(...params, err => {
          if (err) {
            reject(err);
          } else {
            resolve(this);
          }
        });
      });
    }
  }, {
    key: "reset",
    value: function reset() {
      return new this.Promise(resolve => {
        this.stmt.reset(() => {
          resolve(this);
        });
      });
    }
  }, {
    key: "finalize",
    value: function finalize() {
      return new this.Promise((resolve, reject) => {
        this.stmt.finalize(err => {
          if (err) {
            reject(err);
          } else {
            resolve(this);
          }
        });
      });
    }
  }, {
    key: "run",
    value: function run(...params) {
      return new this.Promise((resolve, reject) => {
        this.stmt.run(...params, err => {
          if (err) {
            reject(err);
          } else {
            resolve(this);
          }
        });
      });
    }
  }, {
    key: "get",
    value: function get(...params) {
      return new this.Promise((resolve, reject) => {
        this.stmt.get(...params, err => {
          if (err) {
            reject(err);
          } else {
            resolve(this);
          }
        });
      });
    }
  }, {
    key: "all",
    value: function all(...params) {
      return new this.Promise((resolve, reject) => {
        this.stmt.all(...params, err => {
          if (err) {
            reject(err);
          } else {
            resolve(this);
          }
        });
      });
    }
  }, {
    key: "each",
    value: function each(...params) {
      return new this.Promise((resolve, reject) => {
        const callback = params.pop();
        this.stmt.each(...params, callback, (err, rowsCount = 0) => {
          if (err) {
            reject(err);
          } else {
            resolve(rowsCount);
          }
        });
      });
    }
  }]);

  return Statement;
}();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { return step("next", value); }, function (err) { return step("throw", err); }); } } return step("next"); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

let Database = function () {

  /**
   * Initializes a new instance of the database client.
   * @param driver An instance of SQLite3 driver library.
   * @param promiseLibrary ES6 Promise library to use.
     */

  function Database(driver, { Promise }) {
    _classCallCheck(this, Database);

    this.driver = driver;
    this.Promise = Promise;
  }

  /**
   * Close the database.
   */


  _createClass(Database, [{
    key: 'close',
    value: function close() {
      return new this.Promise((resolve, reject) => {
        this.driver.close(err => {
          if (err) {
            reject(err);
          } else {
            resolve();
          }
        });
      });
    }
  }, {
    key: 'run',
    value: function run(sql, ...params) {
      return new this.Promise((resolve, reject) => {
        this.driver.run(sql, params || [], err => {
          if (err) {
            reject(err);
          } else {
            resolve(this);
          }
        });
      });
    }
  }, {
    key: 'get',
    value: function get(sql, ...params) {
      return new this.Promise((resolve, reject) => {
        this.driver.get(sql, params || [], (err, row) => {
          if (err) {
            reject(err);
          } else {
            resolve(row);
          }
        });
      });
    }
  }, {
    key: 'all',
    value: function all(sql, ...params) {
      return new this.Promise((resolve, reject) => {
        this.driver.all(sql, params || [], (err, rows) => {
          if (err) {
            reject(err);
          } else {
            resolve(rows);
          }
        });
      });
    }

    /**
     * Runs all the SQL queries in the supplied string. No result rows are retrieved.
     */

  }, {
    key: 'exec',
    value: function exec(sql) {
      return new this.Promise((resolve, reject) => {
        this.driver.exec(sql, err => {
          if (err) {
            reject(err);
          } else {
            resolve(this);
          }
        });
      });
    }
  }, {
    key: 'each',
    value: function each(sql, ...params) {
      const callback = params.pop();
      return new this.Promise(resolve => {
        this.driver.each(sql, params, callback, resolve);
      });
    }
  }, {
    key: 'prepare',
    value: function prepare(sql, ...params) {
      return new this.Promise((resolve, reject) => {
        const stmt = this.driver.prepare(sql, ...params, err => {
          if (err) {
            reject(err);
          } else {
            resolve(new Statement(stmt, this.Promise));
          }
        });
      });
    }

    /**
     * Migrates database schema to the latest version
     */

  }, {
    key: 'migrate',
    value: (() => {
      var ref = _asyncToGenerator(function* ({ force, table = 'migrations', migrationsPath = './migrations' } = {}) {
        var _this = this;

        const location = path.resolve(migrationsPath);

        // Get the list of migration files, for example:
        //   { id: 1, name: 'initial', filename: '001-initial.sql' }
        //   { id: 2, name: 'feature', fielname: '002-feature.sql' }
        const migrations = yield new this.Promise(function (resolve, reject) {
          fs.readdir(location, function (err, files) {
            if (err) {
              reject(err);
            } else {
              resolve(files.map(function (x) {
                return x.match(/^(\d+).(.*?)\.sql$/);
              }).filter(function (x) {
                return x !== null;
              }).map(function (x) {
                return { id: Number(x[1]), name: x[2], filename: x[0] };
              }).sort(function (a, b) {
                return a.id > b.id;
              }));
            }
          });
        });

        if (!migrations.length) {
          throw new Error(`No migration files found in '${ location }'.`);
        }

        // Ge the list of migrations, for example:
        //   { id: 1, name: 'initial', filename: '001-initial.sql', up: ..., down: ... }
        //   { id: 2, name: 'feature', fielname: '002-feature.sql', up: ..., down: ... }
        yield Promise.all(migrations.map(function (migration) {
          return new _this.Promise(function (resolve, reject) {
            const filename = path.join(location, migration.filename);
            fs.readFile(filename, 'utf-8', function (err, data) {
              if (err) {
                reject(err);
              } else {
                const [up, down] = data.split(/^\-\-\s+?down/mi);
                if (!down) {
                  const message = `The ${ migration.filename } file does not contain '-- Down' separator.`;
                  reject(new Error(message));
                } else {
                  /* eslint-disable no-param-reassign */
                  migration.up = up.replace(/^\-\-.*?$/gm, '').trim(); // Remove comments
                  migration.down = down.replace(/^\-\-.*?$/gm, '').trim(); // and trim whitespaces
                  /* eslint-enable no-param-reassign */
                  resolve();
                }
              }
            });
          });
        }));

        // Create a database table for migrations meta data if it doesn't exist
        yield this.run(`CREATE TABLE IF NOT EXISTS "${ table }" (
  id   INTEGER PRIMARY KEY,
  name TEXT    NOT NULL,
  up   TEXT    NOT NULL,
  down TEXT    NOT NULL
)`);

        // Get the list of already applied migrations
        let dbMigrations = yield this.all(`SELECT id, name, up, down FROM "${ table }" ORDER BY id DESC`);

        // Undo migrations that exist only in the database but not in files,
        // also undo the last migration if the `force` option was set to `last`.
        const lastMigration = migrations[migrations.length - 1];
        for (const migration of dbMigrations.slice().sort(function (a, b) {
          return a.id < b.id;
        })) {
          if (!migrations.some(function (x) {
            return x.id === migration.id;
          }) || force === 'last' && migration.id === lastMigration.id) {
            yield this.run('BEGIN');
            try {
              yield this.exec(migration.down);
              yield this.run(`DELETE FROM "${ table }" WHERE id = ?`, migration.id);
              yield this.run('COMMIT');
              dbMigrations = dbMigrations.filter(function (x) {
                return x.id !== migration.id;
              });
            } catch (err) {
              yield this.run('ROLLBACK');
              throw err;
            }
          } else {
            break;
          }
        }

        // Apply pending migrations
        const lastMigrationId = dbMigrations.length ? dbMigrations[dbMigrations.length - 1].id : 0;
        for (const migration of migrations) {
          if (migration.id > lastMigrationId) {
            yield this.run('BEGIN');
            try {
              yield this.exec(migration.up);
              yield this.run(`INSERT INTO "${ table }" (id, name, up, down) VALUES (?, ?, ?, ?)`, migration.id, migration.name, migration.up, migration.down);
              yield this.run('COMMIT');
            } catch (err) {
              yield this.run('ROLLBACK');
              throw err;
            }
          }
        }

        return this;
      });

      function migrate(_x) {
        return ref.apply(this, arguments);
      }

      return migrate;
    })()
  }]);

  return Database;
}();

const db = new Database(null, { Promise: global.Promise });

/**
 * Opens SQLite database.
 *
 * @returns Promise<Database> A promise that resolves to an instance of SQLite database client.
 */
db.open = (filename, { mode = null, verbose = false, Promise = global.Promise } = {}) => {
  let driver;

  if (verbose) {
    sqlite3.verbose();
  }

  return new Promise((resolve, reject) => {
    if (mode !== null) {
      driver = new sqlite3.Database(filename, mode, err => {
        if (err) {
          reject(err);
        } else {
          resolve();
        }
      });
    } else {
      driver = new sqlite3.Database(filename, err => {
        if (err) {
          reject(err);
        } else {
          resolve();
        }
      });
    }
  }).then(() => {
    db.driver = driver;
    db.Promise = Promise;
    return new Database(driver, { Promise });
  });
};

module.exports = db;
//# sourceMappingURL=main.js.map